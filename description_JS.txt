============================= js =============================
Содержание:
    Создание переменной let
    Вставить переменную в строку ${someNum} обратные ковычки ``
    Операторы
    Условное ветвлени
        Возвращают false: undefined, 0, "", NaN
    Цыклы
    Функции
        Функции стрелки(arrow functions)
        Cтрелочная функция (arrow function)
    Планирование setTimeout и setInterval
    Объекты
        Тип данных Symbol
        Вложенность
        Свойство из переменной
        обавление свойства
        Удаление свойства
        Изменение свойства
        Копирование объектов
        Дублирование объектов (Object.assign)
            Синтаксис
            Клонирование
            Добавление свойств
        Проверка существования свойства
        Оператор "in"
        Цикл «for…in»
        Использование "this"
    Функция-конструктор
    window.innerWidth (ширина окна браузера)
    BOM
        Navigator
            какой браузер?
            Платформа
        Location
            Получаем URL
            Меняем URL
        History
        Alert
        Сonfirm
        Prompt
    DOM
        Получаем объект body
        Первый и последний дочерние элементы
        Получение детей childNodes
            Отличия от массивов
            Перебор коллекции
                for (let node of childNodes)
        "Живые" коллекции
        Только для чтения
        Соседние и родительский узлы
        ТУТ все собранно по навигации
            Получаем коллекцию всех дочерних узлов
            Получаем коллекцию всех дочерних элементов
            Первый и последний дочерние элементы
            Соседние и родительский элементы
        Поиск произвольного элемента
            Поиск по селектору класса
            Поиск по селектору тега
            Поиск по смешанному селектору тега и класса
            Поиск по тегу первого уровня вложенности
            Поиск по нескольким классам
            Поиск по вложенным классам
            Поиск по ID
            Поиск по атрибуту
            Поиск по атрибуту со значением
        querySelectorAll - статичная коллекция
        Искать можно не только в document
        Неожиданный результат поиска!
        elem.querySelector(CSS);

















'



use strictr';


Создание переменной let
let num;

Присвоение значения 
num = 10;
num = "Привет!";

Константы значения нельзя поменять
const mainPage = document.querySelector('.page');

В const типе object значения можно менять!
const user = {
	name: "Максим",
	age: "26"
}
user.name = "Лоцы";
console.log(user.name)









Вставить переменную в строку ${someNum}
let someString = `Мне ${someNum} лет`;














Операторы
"- + * / % **" оператор сложения "+" НЕ преобразовывает тип данных
Взятие остатка от деления %,
Возведение в степень **.

Операторы сравнения > < >= <= == === != !== 

Логические операторы || && !



















Условное ветвление
if (numOne > numTwo) {
	 Выполняем програму,
	 если условие выполненно (true)
} else if (numTwo === 20) {
} else {}

короткая запись условия (если требуется выполнить одно действие)
let redult = numOne > numTwo ? console.log('numOne больше чем numTwo') : console.log('Условия НЕ выполненны!');

Возвращают false: undefined, 0, "", NaN
if (numOne) {}



















Цыклы
while (i < 5) {
	console.log(i);
	i++;
} 

 если тело состоит из одной строки
while (let i < 5) console.log(i++);

 Конструкция DO...while
let i = 0;
do {
	console.log(i);
	i++
} while (i < 5);

 Цикл for
 for (Начало; Условие; Шаг) {
 	тело цикла
 }
 можно убрать любую часть цикла

 можно остановить выполнение цикла break
 перейти на следущую итерацию continue

* метки  перейти на следующкю итерацию внешнего цикла
firstFor: for (let num = 0; num < 2; num++) {
	for (let size = 0; size < 3; size++) {
		if (size == 2) {
			continue firstFor;
		}
		console.log(size);
	}
} 


for (let node of childNodes){

}

for (let node in childNodes){

}






















Функции

Объявление функции (Function Declaration)
Создание функции
function setConsole(someData) {
     Выполняемый код
}
Вызов функции
setConsole();


Имя функции и её предназначение
Например, функции, начинающиеся с
"show..." обычно что-то показывают,
"get..." – возвращают значение,
"calc..." – что-то вычисляют,
"create..." – что-то создают,
"check..." – что-то проверяют и возвращают логическое
значение, и т.д.


Параметры (аргументы)
function calcSumm(numOne = 1, numTwo = 2) {
	...
}
calcSumm(5, 5);


Функции стрелки(arrow functions)

Функциональное выражение (Function Expression)
let имя переменной = function (параметр, ...параметр) {
    return выражение;
};

Cтрелочная функция (arrow function)
let имя переменной = (параметр, ...параметр) => выражение
let имя переменной = (параметр, ...параметр) => {
	выражение
	}


Однострочная стрелочная функция

let getMessage = (text, name) => text + ', ' + name + '!';



















Планирование setTimeout и setInterval

Что бы реализовать планирование существуют два метода:
1.	setTimeout позволяет вызвать функцию один раз
    через определённый интервал времени
2.	setInterval позволяет вызывать функцию регулярно,
    повторяя вызов через определённый интервал времени.


setTimeout(функция или код, задержка, параметр, ...параметр);
setInterval(функция или код, задержка, параметр, ...параметр);
function showMessage(text, name) {
    console.log(`${text}, ${name}!`);
    setTimeout(showMessage, 500, text, name);
}



















Объекты
let userInfo = new Object();  синтаксис "конструктор объекта"
let userInfo = {};   синтаксис "литерал объекта"

Имена свойств объекта

Имя из двух и больше слов
let userInfo = {
    name: "Вася",
    age: 30,
    "likes javascript": true,
};
console.log(userInfo.name);
console.log(userInfo['name']);
console.log(userInfo["likes javascript"]);

Вычисляем имя
let firstPart = "likes";
let userInfo = {
    name: "Вася",
    age: 30,
    [firstPart + " javascript"]: true,
};
console.log(userInfo["likes javascript"]);

Передаем имя
let firstPart = "likes";
let userInfo = {
    name: "Вася",
    age: 30,
    [firstPart]: true,
};
console.log(userInfo[firstPart]);

Преимущество квадратных скобок
let key = "name";
console.log(userInfo[key]);

Зарезервированные слова в именах let for 




Тип данных Symbol

Создаём символ id с описанием (именем) "id"
let id = Symbol("id");
let userInfo = {
    name: "Вася",
    age: 30,
    [id]: "Некое значение"
};
console.log(userInfo);

Основное применение символов:
1.«Скрытые» свойства объектов
		Символьное свойство не появится в for..in
2. Использование системных символов
 	Symbol.iterator, Symbol.toPrimitive и т.д.




Вложенность
let userInfo = {
    name: "Вася",
    age: 30,
    address: {
        city: "Uzhhorod",
        street: "Freedom",
    }
}




Свойство из переменной

function makeUserInfo(name, age) {
    return {
        name: name,
        age: age,
         ...другие свойства
    };
}

function makeUserInfo(name, age) {
    return {
        name,  Тоже самое что и  name: name,
        age, Тоже самое что и  age: age,
        "likes javascript": true,
         ...другие свойства
    };
}



обавление свойства
let userInfo = {
    name: "Вася",
}
userInfo.age = 30;




Удаление свойства
let userInfo = {
    name: "Вася",
    age: 30,
    "likes javascript": true
}
delete userInfo.age;




Изменение свойства
let userInfo = {
    name: "Вася",
    age: 30,
}
userInfo.age = 18;




Копирование объектов
При копировании объекта в другую переменную
сам объект не дублируется, а копируется только ссылка на него
let userInfo = {
    name: "Вася",
    age: 30,
}
let user = userInfo;
user.age = 18;




Дублирование объектов (Object.assign)
Синтаксис
Object.assign(куда(объект), что(свойство #1), что(свойство #2), ...);
let userInfo = {
    name: "Вася",
    age: 30,
}




Клонирование
let user = Object.assign({}, userInfo);

Пример: слияние объектов
let o1 = { a: 1 };
let o2 = { b: 2 };
let o3 = { c: 3 };
let obj = Object.assign({}, o1, o2, o3);
console.log(obj);  { a: 1, b: 2, c: 3 }




Добавление свойств
let userInfo = {
    name: "Вася",
    age: 30,
}
Object.assign(userInfo, { ['likes javascript']: true, city: "Uzhhorod" });
console.log(userInfo);




Проверка существования свойства
if (userInfo.age) {  true или false}



Опциональная цепочка
let userInfo = {
    name: "Вася",
    age: 30,
    address: {
    	city: "Uzhhorod",
    	street: "Freedom",
    }
}
console.log(userInfo.address.street);  ! получим ошибку если нет!
console.log(userInfo?.address?.street);  использовать









Оператор "in".
В большинстве случаев сработает сравнение с undefined.
либо опциональная цепочка ?.
Но есть особый случай, когда свойство существует,
но содержит значение undefined.
В этом случае необходимо использовать "in".
let userInfo = {
    name: "Вася",
    age: 30,
    address: {
        city: "Uzhhorod",
        street: "Freedom",
    }
}
if ("name" in userInfo) {
    console.log(userInfo.name);
}









Цикл «for…in»
Для перебора всех свойств объекта используется цикл for..in.
Этот цикл отличается от изученного ранее цикла for(;;).
for (let key in object) {
     тело цикла выполняется для каждого свойства объекта
}









Использование "this"
let userInfo = {
    name: "Вася",
    age: 30,
    address: {
        city: "Uzhhorod",
        street: "Freedom",
    },
    showInfo() {
        console.log(`${userInfo.name}, ${userInfo.age} лет. Адрес: г.${userInfo.address.city}, ул.${userInfo.address.street}`);
        console.log(`${this.name}, ${this.age} лет. Адрес: г.${this.address.city}, ул.${this.address.street}`);
    }
}
userInfo.showInfo();









Функция-конструктор

Обычный синтаксис создания объекта{... } позволяет создать
только один объект. Но зачастую нам нужно создать множество
однотипных объектов, таких как пользователи, элементы меню и т.д.
Это можно сделать при помощи функции - конструктора и оператора "new".
Функции - конструкторы являются обычными функциями.
Но есть два правила:
1. Имя функции - конструктора должно начинаться с большой буквы.
2. Функция - конструктор должна вызываться при помощи оператора "new".


function UserInfo(name) {

    this = {}; Создается пустой объект (неявно)

    this.name = name;
    this.age = 30;

    return this; Возвращается объект (неявно)
}

console.log(new UserInfo('Вася'));
console.log(new UserInfo('Лена'));


Когда мы пишем наш код, используя объекты для представления сущностей реального мира,
– это называется объектно - ориентированное программирование или сокращённо: «ООП».

ООП является большой предметной областью и интересной наукой само по себе.
Как выбрать правильные сущности ? Как организовать взаимодействие между ними ?
Это – создание архитектуры, и есть хорошие книги по этой теме,
такие как «Приёмы объектно - ориентированного проектирования.
Паттерны проектирования» авторов Эрих Гамма, Ричард Хелм, Ральф Джонсон,
Джон Влиссидес или «Объектно - ориентированный анализ и проектирование с примерами приложений»
Гради Буча, а также ещё множество других книг.





















WINDOW
const windowWidth = window.innerWidth;
console.log(`Ширина окна браузера: ${windowWidth}px`);




BOM




Navigator
С помощью объекта navigator,
мы можем получить информацию о самом
браузере и операционной системе.

какой браузер?
console.log(navigator.userAgent);

Платформа
console.log(navigator.platform);




Location
С помощью объекта location мы можем
получить текущий URL или
перенаправить браузер по новому адресу.

Получаем URL
console.log(location.href);

Меняем URL
location.href = "https://fls.guru";




History

Объект history позволяет
управлять историей браузера,
передвигаться по посещенным ранее страницам.

history.back();
history.forward();




Alert
alert("Привет!");

Сonfirm
const confirmResult = confirm("Хочешь научиться верстать?");
console.log(confirmResult);

Prompt
const promptResult = prompt("Кто ты по жизни?");
console.log(promptResult);



















DOM
Навигация по документу




Самые верхние элементы дерева
доступны как свойства объекта document

const htmlElement = document.documentElement;
const headElement = document.head;
const bodyElement = document.body;
console.log(htmlElement);
console.log(headElement);
console.log(bodyElement);

Получаем объект body
const bodyElement = document.body;


Первый и последний дочерние элементы
const firstChildNode = bodyElement.firstChild;
const lastChildNode = bodyElement.lastChild;





В документе, возможено, есть ещё «какой-то HTML-код»,
но на момент выполнения скрипта браузер ещё
до него не дошёл.
Поэтому следует размещать скрипт в самом конце
документа




Получение детей childNodes
Коллекция childNodes содержит список всех детей,

включая текстовые узлы.
const childNodes = bodyElement.childNodes;
console.log(childNodes);

Для проверки наличия дочерних узлов
существует также специальная функция hasChildNodes()
console.log(bodyElement.hasChildNodes());


Как мы уже видели,
childNodes похож на массив. На самом деле это не массив,
а коллекция – особый перебираемый объект - псевдомассив.

Отличия от массивов:
1.Для перебора коллекции мы можем использовать for..of:
2.Методы массивов не будут работать, потому что
коллекция – это не массив


Перебор коллекции
for (let node of childNodes) {
	console.log(node); // покажет все узлы из коллекции
}









"Живые" коллекции
Почти все DOM-коллекции, за небольшим исключением, "живые".
Другими словами, они отражают текущее состояние DOM.
Если мы сохраним ссылку на body.childNodes и добавим/удалим
узлы в DOM, то они появятся в сохранённой коллекции автоматически.
Еще вернемся к этому позже.




Только для чтения
DOM-коллекции, и даже более – все навигационные свойства,
перечисленные далее, доступны только для чтения.
Мы не можем заменить один дочерний узел на другой,
просто написав childNodes[i] = ....
Для изменения DOM требуются другие методы.






ТУТ все собранно по навигации
Навигационные свойства, описанные выше, относятся
ко всем узлам в документе.
В частности, в childNodes находятся и текстовые узлы и
узлы-элементы и узлы-комментарии, если они есть.


Получаем коллекцию всех дочерних узлов
const childNodes = bodyElement.childNodes;
console.log(childNodes);


Но для большинства задач текстовые узлы и
узлы-комментарии нам не нужны. Мы хотим манипулировать
узлами-элементами, которые представляют собой теги и
формируют структуру страницы.


Получаем коллекцию всех дочерних элементов
const bodyСhildren = bodyElement.children;
console.log(bodyСhildren);


Первый и последний дочерние элементы
const firstChild = bodyElement.firstElementChild;
const lastChild = bodyElement.lastElementChild;
console.log(firstChild);
console.log(lastChild);

Соседние и родительский элементы
const previousSibling = bodyElement.previousElementSibling;
const nextSibling = bodyElement.nextElementSibling;
const parentElement = bodyElement.parentElement;

console.log(previousSibling);
console.log(nextSibling);
console.log(parentElement);









Поиск произвольного элемента

Поиск по селектору класса
const elemsOne = document.querySelectorAll('.lesson__list');
console.log(elemsOne);

Поиск по селектору тега
const elemsTwo = document.querySelectorAll('li');
console.log(elemsTwo);

Поиск по смешанному селектору тега и класса
const elemsThree =
	document.querySelectorAll('li.lesson__item-list');
console.log(elemsThree);

Поиск по тегу первого уровня вложенности
const elemsFour =
	document.querySelectorAll('.lesson__list>li');
console.log(elemsFour);

Поиск по нескольким классам
const elemsFive =
	document.querySelectorAll('.lesson__list, .lesson__text');
console.log(elemsFive);

Поиск по вложенным классам
const elemsSix =
	document.querySelectorAll('.lesson__list .lesson__text');
console.log(elemsSix);

Поиск по ID
const elemsSeven =
	document.querySelectorAll('#listItem');
console.log(elemsSeven);

Поиск по атрибуту
const elemsEight =
	document.querySelectorAll('[data-item]');
console.log(elemsEight);

Поиск по атрибуту со значением
const elemsNine =
	document.querySelectorAll('[data-item="85"]');
console.log(elemsNine);









querySelectorAll - статичная коллекция

Получение конкретного элемента коллекции

const elems = document.querySelectorAll('li');
console.log(elems[2]);

for (const item of elems) {
	console.log(item);
}

elems.forEach(item => {
	console.log(item);
});




Искать можно не только в document

const subList = document.querySelectorAll('.lesson__sub-list');
const subItems = subList[0].querySelectorAll('li');
console.log(subItems);




Неожиданный результат поиска

const subList =
	document.querySelectorAll('.lesson__sub-list');
const listItems =
	subList[0].querySelectorAll('.lesson__list .lesson__item-sub-list');
console.log(listItems);

В данном примере,
когда мы выбрали ".lesson__list .lesson__item-sub-list"
в контексте <ul> с классом "lesson__sub-list", элемент с классом
".lesson__item-sub-list" были всё равно найден, хотя
.lesson__list не является потомком элемента в котором происходил
поиск (".lesson__sub-list").

По умолчанию, querySelectorAll() проверяет только последний
элемент без учёта контекста.









elem.querySelector(CSS);
































Получаем коллекцию объектов
const listItems = document.querySelectorAll('.list__item');

Пробежаться по объектам forEach
listItems.forEach(function (listItem) {
	Работаем с каждым объектом
});

Проверяем колекцию
if (listItems.length) {
	console.log('Есть!');
}

Получаем первый объект
const list = document.querySelector('.list');

Проверяем один объект
if (list) {
}




Работа с классами
const listElement = document.querySelector('.list');

listElement.classList.add('active');  НЕ СТАВИТЬ ТОЧКУ!!!!!
listElement.classList.remove('active');
listElement.classList.toggle('active');


Проверяем есть ли класс
if (listElement && listElement.classList.contains('list')) { НЕ СТАВИТЬ ТОЧКУ!!!!!
	console.log('Юху!');
}

const listItems = document.querySelectorAll('.list__item');
if (listItems.length) {
	listItems.forEach(function (listItem) {
		if (listItem.classList.contains('active')) { НЕ СТАВИТЬ ТОЧКУ!!!!!
			console.log('Юху!');
		}
	});
}




































Запрет f12
window.onkeydown = function(evt) {
    if(evt.code == "F12") return false;
};

Проверка мобильного браузера
import { isMobile } from "./functions";
